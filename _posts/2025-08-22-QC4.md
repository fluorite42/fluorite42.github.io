---
title: "An Introduction to Quantum Error Correction, Part 2: Logical Qubits and Code Distance"
category: Quantum Computing

toc: true
toc_sticky: true
toc_label: "An Introduction to Quantum Error Correction, Part 2: Logical Qubits and Code Distance"
toc_icon: "bolt-lightning"

excerpt: |
    This post explores the mathematical framework that enables error correction and quantifies a code's power. 
    We will define the logical operators that manipulate encoded information and introduce code distance, the key metric for a code's ability to combat noise.
header:
  overlay_image: /assets/images/header_nixie.jpg
  caption: "Photo credit: [**Unsplash**](https://unsplash.com/photos/purple-and-black-led-lights-Jy9TgpggCP8)"
  overlay_filter: 0.5

date: 2025-08-22
last_modified_at: 2025-08-22
---



## Introduction

### Recap of Part 1: From Errors to Syndromes

In Part 1, we laid the groundwork for the stabilizer formalism. 
We learned how to define a protected **codespace** using a set of commuting Pauli operators—the **stabilizers**. 
By measuring these stabilizers, we can extract an **error syndrome**, a unique fingerprint that signals the presence of an error without destroying the underlying quantum state.

This process is powerful, but it only completes the first step: **error detection**. 
Knowing an error has occurred is different from knowing how to fix it, or even *if* it's fixable.

### The Next Challenge: From Detection to Correction

This raises several crucial questions: 
What mathematical conditions must a code satisfy to be truly *correctable*? 
Once we encode our information, how do we perform computations on it? 
And how can we quantify the power of one code versus another?

In this second part, we will answer these questions by diving into the core mathematics of QEC. 
We will define the **logical operators** that act on our protected qubits, establish the formal **conditions for error correction**, and introduce the single most important metric for a code's performance: the **code distance**. 
By the end of this post, you'll have the theoretical tools to not just identify errors, but to understand the principles of correcting them and evaluating the strength of any stabilizer code.



## 1. The Conditions for Correcting Errors

In the previous post, we established that measuring stabilizers reveals a syndrome that signals the presence of an error. 
Now, we must establish the rigorous conditions under which a measured syndrome can lead to a successful correction. 
The core principle is **distinguishability**: the code must be able to distinguish between errors that have a different effect on the encoded logical information.

### 1.1 Distinguishing Errors

After a syndrome is measured, the decoder's task is to apply a recovery operation. 
If two distinct errors, $E_a$ and $E_b$, produce the exact same syndrome, the decoder cannot distinguish between them. 
If the decoder assumes the error was $E_a$ and applies the correction $E_a^\dagger$, but the true error was $E_b$, the final state of the system will be:

$$E_a^\dagger E_b |\psi_L\rangle$$

The system is successfully restored to the codespace if and only if the composite operator $E_a^\dagger E_b$ has no net effect on the logical state. 
If $E_a^\dagger E_b$ alters the logical state, the correction will fail, resulting in a logical error.

Two errors $E_a$ and $E_b$ produce the same syndrome if and only if they have the same commutation relations with all stabilizer generators. 
This is equivalent to the condition that the operator $E_a^\dagger E_b$ commutes with the entire stabilizer group $S$, meaning $E_a^\dagger E_b \in Z(S)$.

### 1.2 The Stabilizer Error Correction Condition

This leads to the formal mathematical condition for quantum error correction. 
A stabilizer code with stabilizer group $S$ 
can correct a set of Pauli errors 
$$\mathcal{E} = \{E_i\}$$ 
if and only if for all pairs $E_a, E_b \in \mathcal{E}$:

$$E_a^\dagger E_b \notin Z(S) \setminus S$$

Let's break down this crucial statement:

* **$Z(S)$** is the **centralizer** of S: the set of all Pauli operators that commute with every stabilizer in S.
* **$S$** is the **stabilizer group** itself.
* **$Z(S) \setminus S$** is the set of operators that commute with all stabilizers but are **not** stabilizers themselves. 
As we will see in the next section, these are the **non-trivial logical operators**.

The condition can be interpreted as follows: 
for any two correctable errors $E_a$ and $E_b$, the operator $E_a^\dagger E_b$ must either:

1.  **Be an element of $S$**. 
In this case, $E_a$ and $E_b$ produce the same syndrome but are equivalent on the codespace ($E_b = E_a g$ for some $g \in S$), so applying the wrong correction is harmless.
2.  **Not be an element of $Z(S)$**. 
This means $E_a^\dagger E_b$ anti-commutes with at least one stabilizer. 
This implies $E_a$ and $E_b$ produce different syndromes and are therefore distinguishable.

The failure condition is when $E_a^\dagger E_b$ is a non-trivial logical operator. 
In this case, the errors produce the same syndrome but have a different effect on the logical state, making them fatally indistinguishable.

### 1.3 Degenerate vs. Non-Degenerate Codes

This condition gives rise to two classes of codes:

* **Non-Degenerate Codes:** 
In these codes, every correctable error (aside from the trivial identity) maps to a unique syndrome. 
This is the simplest case to analyze but often leads to less efficient codes.
* **Degenerate Codes:** 
In these codes, multiple distinct physical errors can map to the same syndrome. 
This is perfectly acceptable as long as for any two such errors $E_a$ and $E_b$, their combination $E_a^\dagger E_b$ is an element of the stabilizer group $S$. 
Many of the most powerful codes, including the surface code, are degenerate.



## 2. Operating on Encoded Information

Now that we have a protected codespace, we need a way to perform computations on the logical qubits encoded within it. 
This requires defining a new set of operators---logical operators---that act on the encoded information while preserving the integrity of the code.

### 2.1 Logical Operators

A **logical operator** is an operator $\bar{L}$ that maps the codespace $\mathcal{C}$ to itself. 
If $|\psi_L\rangle$ is a valid codeword in the codespace, then $\bar{L}|\psi_L\rangle$ must also be a valid codeword.

For $\bar{L}|\psi_L\rangle$ to remain in the codespace, it must still be a +1 eigenvector of every stabilizer $g \in S$. T
his leads to the following condition:

$$g(\bar{L}|\psi_L\rangle) = \bar{L}|\psi_L\rangle$$

This identity holds if and only if the logical operator $\bar{L}$ commutes with every stabilizer $g \in S$. 
Therefore, the set of all logical operators is precisely the **centralizer** of the stabilizer group:

$$\bar{L} \in Z(S)$$

### 2.2 Trivial vs. Non-Trivial Operators: Stabilizers vs. Gates

The centralizer $Z(S)$ contains two distinct classes of logical operators, defined by their relationship to the stabilizer group $S$ itself.

* **Trivial Logical Operators ($\bar{L} \in S$):** 
These are logical operators that are also elements of the stabilizer group. 
Since any stabilizer $g$ acts as the identity on the codespace ($g|\psi_L\rangle = |\psi_L\rangle$), these operators are equivalent to the logical identity gate, $\bar{I}$. 
They do not perform any computation.
* **Non-Trivial Logical Operators ($\bar{L} \in Z(S) \setminus S$):** 
These are operators that commute with all stabilizers but are not stabilizers themselves. 
These are the operators that perform meaningful computations—the logical gates. 
This set is precisely the one we identified in the previous section as being problematic for error correction, as these operators are indistinguishable from the identity error. 
They represent the smallest errors that can corrupt the logical state without triggering a syndrome.

### 2.3 The Logical Pauli Operators: $\bar{X}$, $\bar{Y}$, and $\bar{Z}$

The set of non-trivial logical operators forms a consistent algebra for our encoded information. 
For each of the $k$ logical qubits in an `[[n, k, d]]` code, we can define a set of logical Pauli operators $\{\bar{X}, \bar{Y}, \bar{Z}\}$ that behave exactly like the physical Pauli matrices on the logical states.

These operators are chosen from the set $Z(S) \setminus S$ and must satisfy the standard Pauli commutation relations:

* $\bar{X}^2 = \bar{Z}^2 = \bar{I}$ (on the codespace)
* $\bar{Z}\bar{X} = -\bar{X}\bar{Z}$ (they must anti-commute)

From these, the logical Y can be defined as $\bar{Y} = i\bar{X}\bar{Z}$. 
For example, in the 3-qubit bit-flip code from Part 1, a valid choice for the logical operators is:

* **Logical Z:** $\bar{Z} = Z_1$ (or $Z_2$ or $Z_3$)
* **Logical X:** $\bar{X} = X_1 X_2 X_3$

One can verify that both operators commute with the stabilizers ($Z_1Z_2$ and $Z_2Z_3$) but anti-commute with each other, thus forming a valid set of logical gates for the encoded qubit.



## 3. Measuring a Code's Power

To compare different QEC codes, we need a metric to quantify their performance. 
The **code distance** is the single most important parameter for measuring a code's robustness against errors.

### 3.1 Defining Code Distance (d)

In the last section, we identified non-trivial logical operators ($\bar{L} \in Z(S) \setminus S$) as operations that change the logical state but commute with all stabilizers, making them invisible to syndrome measurements.

The **distance (d)** of a stabilizer code is the minimum **weight** of any non-trivial logical operator. 
The weight of a Pauli operator is the number of qubits on which it acts non-trivially.

$$d = \min_{\bar{L} \in Z(S) \setminus S} \{ \text{weight}(\bar{L}) \}$$

Essentially, **the distance is the size of the smallest possible error that can corrupt the encoded information without being detected**. 
A larger distance means a more powerful code, as a more complex error is required to cause a logical fault.

### 3.2 How Distance Determines Corrective Power

The code distance directly determines its error-correcting capability. 
A code with distance $d$ can *detect* any error affecting up to $d-1$ qubits and can *correct* any error affecting up to $t$ qubits, where $t$ is given by:

$$t = \left\lfloor \frac{d-1}{2} \right\rfloor$$

This relationship arises from the need to distinguish errors. 
For a code to correct any two errors $E_a$ and $E_b$ of weight up to $t$, the composite operator $E_a^\dagger E_b$ must be detectable. 
The weight of this operator is at most $2t$. 
If $2t < d$, its weight is less than that of the smallest undetectable (logical) error, so it must be detectable. 
This condition, $2t < d$, leads directly to the formula above.

For example, a code with **d=3** can correct $t=1$ errors, meaning it can correct any arbitrary single-qubit Pauli error ($X, Y,$ or $Z$) on any qubit. 
This is a critical benchmark for useful QEC codes.

### 3.3 Physical Limits: The Quantum Singleton Bound

A code's parameters are not arbitrary; 
they are constrained by the laws of quantum information. 
The **quantum Singleton bound** provides a fundamental trade-off between the number of physical qubits ($n$), logical qubits ($k$), and the distance ($d$).

For any `[[n, k, d]]` code, the parameters must satisfy:

$$n - k \ge 2(d-1)$$

This inequality shows that increasing a code's distance or the number of logical qubits it protects requires a corresponding increase in the number of physical qubits. 
For instance, the famous `[[5, 1, 3]]` code perfectly satisfies this bound, as $5-1 = 4$ and $2(3-1) = 4$. 
Codes that meet this bound are considered highly efficient.

As a counterexample, the `[[3, 1, 3]]` bit-flip code violates this inequality. 
Its parameters give $n-k=2$, which is less than the required $2(d-1)=4$. 
The bound is not met because it assumes the code can correct any arbitrary error of weight $t=1$; 
the bit-flip code is specialized and, as shown in Part 1, fails to protect against Z-type phase errors.


---

**What's Next: From Theory to Practice**

With this theoretical framework in place, we are now ready to see how these principles are applied to construct real-world codes. 
In the next part of this series, we will analyze some of the most historically significant examples in the field. 
We will apply our knowledge of stabilizers, logical operators, and distance to deconstruct two cornerstones of QEC: the Shor code and the elegant Steane code.